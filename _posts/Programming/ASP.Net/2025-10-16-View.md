---
categories : View
---

# View

## Razor

View也叫Razor视图,使用Razor表达式和代码(Razor在服务器中执行,Html在浏览器中运行).

Razor代码,在View中可以编写多个

```
@{
    //C#
}
```

Razor表达式

```
@Expression
--or--
@(Expression)

```

razor if

可以在C#中控制html

```C#
@if()
{
    //C#和html都可以
    <h1>something</h1>
}
else
{

}
```

razor switch

```C#
@switch()
{
    case://
}
```

razor foreach

```C#
@foreach(Person person in people)
{

}
```

razor for

```C#
@for()
{

}
```

因为@for和@if或其他的可以嵌套所以
如果编辑器分不清是C#代码还是html,就用`<text>text</text>`和`@`区分.

**局部函数**

只能在局部使用,但是@if,@{}或其他都在一个作用域.

```C#
@{
    double? GetAge(DateTime? dateOfBirth)
    {
        if (!dateOfBirth.HasValue) return null;
        return Math.Round((DateTime.Now - dateOfBirth).Value.TotalDays / 365);
    }
}

//some code

@if (person.DateOfBirth.HasValue)
{
    <span>@GetAge(person.DateOfBirth)</span>
}
```
**方法**

```C#
@function
{

}
```

>[!TIP]
>其实razor函数和方法并不常用,因为在cshtml中不应存在大量C#代码,而是应该放在控制器中.

`@Html.Raw(javaScriptCode)` 执行,而不是打印(不要从用户输入来使用此代码)

## 基础使用

控制器
```C#
// GET: HomeController.cs
[Route("home")]
public ActionResult Index()
{
    //Views/Home/Index.cshtml 约定,默认位置,以方法为名,
    //返回视图模型
    return View();
    
    //return View("abc"); //abc.cshtml 改名
    //return new ViewResult() { ViewName = "abc" };
}
```
View

```html
@using ViewsExample.Models

@{
    string appTitle="ASP.NET Core Application";
    Person person=new Person(){ Name = "la",DateOfBirth = Convert.ToDateTime("1990-01-01")};
}

<!DOCTYPE html>

<html>
    <head>
        <title>@appTitle</title>
        <meta charset="UTF-8"/>
    </head>
    <body>
        <h1>welcom</h1>
        <h2>Hello @person.Name</h2>
        @{
            var age = Math.Round((DateTime.Now - person.DateOfBirth).TotalDays / 365);
        }
        <h3>@age years old</h3>
    </body>
</html>
```

## ViewData

视图数据,字典,由控制器提供给视图,是`Controller的属性`

```C#
public class HomeController : Controller
{
    [Route("home")]
    public ActionResult Index()
    {
        //在对应视图中直接可以得到@ViewData["app"]
        ViewData["app"] = "apple";
        return View();
    }
}

//cshtml
<h3>@ViewData["app"]</h3>
```

视图不应该主动初始化数据,而是由控制器提供

### ViewBag

数据包,语法糖,  
`@ViewData["app"]`得到的是个`Object`类型,因为他是个字典  
使用数据包不需要显示转换,它是个`dynamic`类型,运行时解析.**方便在foreach中使用**在编写代码时,不要使用`var`,因为它不知道是什么类型.

```C#
//C#
ViewBag.people=people;

//<h3>@ViewData["app"]</h3>
<h4>@ViewBag.app</h4>
```

## 强类型视图

只能绑单一模型

当视图使用`@`表明了类型,控制器传入了model,那么这个视图被称为强类型视图.

```C#
public class HomeController : Controller
{
    [Route("home")]
    [Route("/")]
    public ActionResult Index()
    {
        List<Person> persons = new List<Person>()
        {
            new Person() { Name = "John", DateOfBirth = new DateTime(1990, 1, 1) },
            new Person() { Name = "Mary", DateOfBirth = new DateTime(1995, 5, 5) },
            new Person() { Name = "Tom", DateOfBirth = null }
        };
        //将模型直接传入视图模型,如果要定义视图名称则 View("name",persons) 第一个参数为名称,第二个为模型
        return View(persons);
    }
}
```

在`cshtml`顶部加入`@model List<Person>`

```C#
@model List<Person>

//直接使用Model关键字获得模型
@foreach (var person in Model)
{
    <div class="box w-50">
        <span>@person.Name @person.DateOfBirth?.ToString() @GetAge(person.DateOfBirth)</span>
    </div>
}
```

### 如何绑定多个模型

使用包装类

```C#
public class Product
{
    public int ProductId { get; set; }
    public string? ProductName { get; set; }
}

public class Person
{
    public string Name { get; set; }
    public DateTime? DateOfBirth { get; set; }
}

//包装类
public class PersonAndProductWrapperModel
{
    public Person Person { get; set; }
    public Product Product { get; set; }
}
```

```C#
//控制器
public IActionResult PersonWithProduct()
{
    Person person = new Person() { Name = "Alice", DateOfBirth = new DateTime(1988, 8, 8) };
    Product product = new Product() { ProductId = 1, ProductName = "Laptop" };
    
    //传入包装类模型
    return View(new PersonAndProductWrapperModel(){Person = person, Product = product});
}

//csthml
@model ViewsExample.Models.PersonAndProductWrapperModel
```

## _ViewImports

`固定名称`

一个导入文件  
里面的`@using` 和 `@Model` 等配置会对被影响的`Views`起效.

**不要在里面编写逻辑代码,单一原则**

* Views
  * _ViewImports.cshtml (Views下,对所有视图起效，全局)
  * ControllerName
    * _ViewImports.cshtml (控制器下,对当前控制器的起效，局部)

全局和局部的并不会冲突和覆盖,而是叠加.

## Shared

`固定名称`

在Shared中的视图能被所有控制器得到.

* Views
  * Shared
    * ViewName.csthml  

```C#
return View();
/Views/Controller/ViewName.cshtml 首选位置  
/Views/Shared/ViewName.cshtml 次要位置
```

### 布局

`固定名称`

会用在所有视图中,不会直接执行.

* Views
  * Shared
    * _Layout.csthml  

`@RenderBody()` 指实际的内容,一定要有.

执行顺序
1. _ViewImports
2. _ViewStart
3. View
4. LayoutView

**快速创建视图**  
将光标停在View()中.`alt+enter`->`使用布局创建视图`.(Rider)
```C#
[Route("/about-company")]
public ActionResult About()
{
    return View();
}
```


View
```C#
@{
    //启动布局
    Layout = "_Layout";
}
```
----------------------------------

**动态布局**

其实就是一个小技巧

```C#
//控制器
[Route("/search-products/{ProductID?}")]
public ActionResult Search(int? ProductID)
{
    ViewBag.productID = ProductID;
    return View();
}
```

```C#
@{
    ViewBag.Title = "title";
    if (ViewBag.ProductID!=null)
    {
        //Layout=someLayout;
    }
}
```

------------------------

**Section 和 @RenderSection**

用来应对某些只在单个页面需要的脚本.

```C#
//_Layout
<div class="footer-content">
    //渲染章节,非必须的,如果视图中有的话就渲染,没有就不渲染
    @RenderSection("footer_section", required: false)
</div>
```
```C#
//在视图中定义章节
@section footer_section
{
    <p>Contact support:888</p>    
}
```
-----------------------

**嵌套布局**

**实际中用的非常少**

将`_Layout`的布局在嵌套给其他布局.

```C#
//_Layout
@{
    Layout="someLayout";
}
```

那么一个视图会先被`_Layout`包装在里面,`_Layout`又被其他一个布局包装在里面.

### _ViewStart.cshtml

`固定名称`

和`_ViewImports`几乎一样,只不过一个用来导入,一个用来设置Layout.

* Views
  * _ViewStart.cshtml (Views下,对所有视图起效，全局)
  * ControllerName
    * _ViewStart.cshtml (控制器下,对当前控制器的起效，局部)

**全局和局部的会参生冲突和覆盖**,`ControllerName`里面的会覆盖外面的.