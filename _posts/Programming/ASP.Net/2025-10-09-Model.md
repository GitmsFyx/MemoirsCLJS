---
categories: ASP.net
---

# Model

模型绑定,框架功能,自动提供

## 框架自动获得参数

简化得到参数的过程,  
不必`ControllerContext.HttpContext.Request.RouteValues["id"]`

```C#
//设置路由参数
[Route("store/books/{id}")]
//设置参数
public ActionResult Books(int id)
{
    //框架会将URL的参数传入id
    return Content($"<h1>Book Store {id}</h1>");
}
```
### 明确数据源

```C#
[Route("store/books/{id}")]
//只从路由中获得参数.
//还有[FromQuery].
public ActionResult Books([FromRoute]int id)
{

    return Content($"<h1>Book Store {id}</h1>");
}
```

## 模型绑定

Model 类
```C#
public class Book
{
    public int BookId { get; set; }
    public string? Author { get; set; }

    public override string ToString()
    {
        return $"BookId: {BookId}, Author: {Author}";
    }
}
```

控制器方法

```C#
[Route("bookstore/{bookid?}/{isloggedin?}")]
//这里的Book的bookid会被填充,由路由参数或查询语句相同的变量填充,大小写不敏感
//如果Book前面添加[FromQuery],那么它只会被查询语句填充.
public IActionResult BookStore([FromQuery]int? bookid,[FromRoute]bool? isloggedin,Book book)
{
    return RedirectToAction("Books","Store",new {});
}
```

为Book不同属性设定来源

```C#
public class Book
{
    [FromQuery]
    public int BookId { get; set; }
    [FromRoute]
    public string? Author { get; set; }

    public override string ToString()
    {
        return $"BookId: {BookId}, Author: {Author}";
    }
}
```

------------------------------------------

**从表单JSON格式绑定模型**  

在请求头中会包含内容类型,ASP.Core会识别并且其内置了转化Json的功能(默认只开启这一种)

在Postman中需要使用`Body->raw->Json`

>[!WARNING]
>`[FromBody]`虽然表面是写了来自Body,实际上只接收JSON和XML。其他Body不接收.

```C#
//需要FromBody指明表单,
public IActionResult Index([FromBody]Person person)
```

**从表单XML格式绑定模型**  

老旧项目可能会用

在Postman中需要使用`Body->raw->XML`

```C#
//Program.cs
//开启XML格式化
builder.Services.AddControllers().AddXmlSerializerFormatters();
```

控制器

```C#
//需要FromBody指明表单
public IActionResult Index([FromBody]Person person)
```

-----------------------------------------------

**集合绑定**

```C#
public List<string?> Tags { get; set; } = new List<string?>();
```

在Postman中,发送`x-www-form-urlencoded`,Tags[0],Tags[1],....

**请求头绑定**

```C#
//FromHeader(Name = "User-Agent")] 直接从请求头中的"User-Agent"获得
public IActionResult Index(Person person,[FromHeader(Name = "User-Agent")]string UserAgent)
```

### 指定绑定

Bind(建议使用)

默认为绑定所有参数,如果写了Bind那么就只接受Bind了的,其他不接受  
防止恶意提交

```C#
public class HomeController : Controller
    {
        // GET: HomeController
        [Route("register")]
        //使用[Bind(nameof(some),nameof(some))]Person person,来表示Person只接受绑定的属性
        public IActionResult Index([Bind(nameof(Person.PersonName),nameof(Person.Email),nameof(Person.Password),nameof(Person.ConfirmPassword))]Person person)
        {
            //something
        }
    }
```

BindNever

排除某个属性,在属性上面注释

```C#
//不Bind某个属性
[BindNever]
public string? Email { get; set; }
```

### 自定义绑定

`IModelBinder` 接口,已经和视频中的用法不一样,略过

`ImodelBinderProvider` 一起略过


## 验证规则

### 控制器模型验证
`using System.ComponentModel.DataAnnotations;`

```C#
public class Person
{
    //必须提供,{0}为自己的名字,可以被Display修改
    [Required(ErrorMessage = "{0} No Name")]
    [Display(Name = "Person Name")]
    //{1}为第一个参数,{2}为第二个参数
    [StringLength(11, MinimumLength = 3, ErrorMessage = "{0} must be between {2} and {1} characters")]
    [RegularExpression("^[A-Za-z .]+$", ErrorMessage = "{0} must contain only letters, spaces, and periods")]
    public string? PersonName { get; set; } 

    //已经封装正确的Email表达式
    [EmailAddress(ErrorMessage = "{0} is not valid")]
    public string? Email { get; set; }
    
    [Required]
    //已经封装正确的电话号码表达式
    [Phone(ErrorMessage = "{0} is not valid")]
    //取消验证这个属性
    //[ValidateNever]
    public string? Phone { get; set; }

    [Required]
    public string? Password { get; set; }

    //与password比较,不同则验证失败
    [Compare("Password", ErrorMessage = "{0} does not match {1}")]
    public string? ConfirmPassword { get; set; }
    
    //0到999的范围
    [Range(0,999, ErrorMessage = "{0} must be between {1} and {2}")]
    public double? Price { get; set; }
    
    public override string ToString()
    {
        return $"PersonName: {PersonName}, Email: {Email}, Phone: {Phone}, Password: {Password}, ConfirmPassword: {ConfirmPassword}, Price: {Price}";
    }
}
```
>[!Warning]
>验证出错误程序并不会报错,只是修改ModelState的值.所以要用`ModelState`判断.

`ModelState` 控制器里面的属性,包含以下属性:
- `IsValid` Ture表示没有验证错误
- `Values` 所有提供的值
- `ErrorCount` 错误数量

```C#
    public class HomeController : Controller
    {
        // GET: HomeController
        [Route("register")]
        public IActionResult Index(Person person)
        {
            if (!ModelState.IsValid)
            {
                //使用LINQ,将values里面的每个value的每个error的错误信息连接
                string errors =
                    string.Join("\n",
                    ModelState.Values.SelectMany(value => value.Errors)
                    .Select(error => error.ErrorMessage).ToList());
                /*
                foreach (var value in ModelState.Values)
                {
                    foreach (var error in value.Errors)
                    {
                        errorsList.Add(error.ErrorMessage);
                    }
                }*/
                return BadRequest($"{errors}");
            }
            
            return Ok(person.ToString());
            
        }

    }
```

### 模型验证

```C#
public class ValidationHelper
{
    internal static void ModelValidation(object obj)
    {
        //Model Validations

        //创建验证上下文,需输入验证模型
        ValidationContext validationContext = new ValidationContext(obj);
        //创建验证结果,下面会用
        List<ValidationResult> validationResults = new List<ValidationResult>();
        //执行验证和返回是否成功验证bool,最后一个参数(是否验证所有属性,否则验证必须属性)
        var tryValidateObject = Validator.TryValidateObject(personAddRequest, validationContext, validationResults, true);

        if (tryValidateObject)
        {
            throw new ArgumentException(validationResults.FirstOrDefault()?.ErrorMessage);
        }
    }
}
```


### 自定义验证

单个属性的验证

```C#
//必须继承ValidationAttribute
//后缀Attribute是约定
public class MinimumYearValidatorAttribute : ValidationAttribute
{
    //预定义两个属性
    public int MinimumYear { get; set; } = 2000;
    public string DefaultErrorMessage { get; set; } = "Minimum year allowed is {0}";
    //要提供无参,因为有了预定义,可以什么都不传
    public MinimumYearValidatorAttribute()
    {
    }
    //自定义最小年份
    public MinimumYearValidatorAttribute(int minimumYear)
    {
        MinimumYear = minimumYear;
    }
    //重写Isvalid,返回值为ValidationResult的方法.还有一个同名的bool的方法.
    protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
    {
        if (value != null)
        {
            DateTime date = (DateTime)value;
            if (date.Year<=MinimumYear)
            {
                //return new ValidationResult("minmum year allowed is 2000");
                
                //相当于string.Format("Minimum year allowed is {0}",MinimumYear)
                //这样可以把MinimumYear格式化进去
                return new ValidationResult(string.Format(ErrorMessage??DefaultErrorMessage, MinimumYear));
            }
            else
            {
                return ValidationResult.Success;
            }
        }

        //如果value为null,返回null,相当于不验证,
        //如果返回错误信息,相当于value不能为空,如[Required]
        return null;
    }
}
```

-----------------------------------------

多个属性的验证(表单验证)

属性注释,`DateRangeValidator`

```C#
public DateTime? FromDate { get;set; }

[DateRangeValidator("FromDate", ErrorMessage = "{0} must be greater than {1}")]
public DateTime? ToDate { get;set; }
```

定义类 `DateRangeValidatorAttribute`, Attribute为后缀.

```C#
public class DateRangeValidatorAttribute : ValidationAttribute
{
    //构造器传入参数,为另一个要对比的属性
    public string OtherProertyName { get; set; }
    public DateRangeValidatorAttribute(string otherPropertyName)
    {
        OtherProertyName = otherPropertyName;
    }
    
    //IsValid 方法
    //FromDate 2002-10-20
    //Todate   2001-01-01
    //输出
    //ToDate must be greater than FromDate
    //ToDate must be greater than FromDate
    protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
    {
        if (value != null)
        {
            //value为被验证的属性数值(被打上注释的),2001/1/1 00:00:00
            DateTime to_date = Convert.ToDateTime(value);

            //validationContext里面存有验证的许多信息
            //ObjectType是被验证的类，也就是Person
            //GetProperty(OtherProertyName) 获得了person类里面的FromDate属性信息
            PropertyInfo? otherProperty = validationContext.ObjectType.GetProperty(OtherProertyName);

            if (otherProperty != null)
            {
                //validationContext.ObjectInstance为被验证的具体实例
                //从被验证的person实例中获得FromDate属性
                DateTime from_date = Convert.ToDateTime(otherProperty.GetValue(validationContext.ObjectInstance));
                if (from_date > to_date)
                {
                    //第二个参数是报告的属性对象.会给FromDate报告一次,ToDate报告一次
                    return new ValidationResult(string.Format(ErrorMessage, validationContext.DisplayName, OtherProertyName),
                        new string[] { OtherProertyName, validationContext.MemberName });
                }
                else
                {
                    return ValidationResult.Success;
                }
            }
        }
        //为null为不判断
        return null;
    }
}
```

---------------------------------

**给对象的验证方法**

必须通过属性验证才能运作

```C#
//实现接口
public class Person : IValidatableObject
```

```C#
public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
{
    if(DateOfBirth.HasValue==false && Age.HasValue==false)
    {
        //yield 逐渐返回 并且不结束方法 只是暂停方法
        yield return new ValidationResult("Either DateOfBirth or Age is required", new [] { nameof(DateOfBirth) , nameof(Age) });
    }
}
```

## 表单 post

### form-urlencoded(default)

处理少量信息

*Request Headers* : 
    
    Content-Type:application/x-www-form-urlencoded

*Request Body* : 
    
    param1=value&param2=value2

### form-data

处理大量信息时候使用,**可以添加附件文件**

*Request Headers* : 
    
    Content-Type:multipart/form-data

*Request Body* : 

    -------随机字符
    Content-Disposition:
    value1

