---
categories: ASP.net
---

# Entity Framework Core

内部使用的`ADO`,方便编写,性能相比略差。

默认使用依赖注入.

属性注释 [Key]为ID唯一值

## 使用

```C#
//DbContext对应的数据库
public class PersonsDbContext : DbContext
{
    //DbSet对应的是一张表,泛型,名称使用复数.
    public DbSet<Country> Countries { get; set; }
    public DbSet<Person> Persons { get; set; }

    //配置表
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.Entity<Country>().ToTable("Countries");
        modelBuilder.Entity<Person>().ToTable("Persons");
    }
}
```

```C#
//Program.cs
//依赖注入
builder.Services.AddDbContext<PersonsDbContext>(options =>
{
    //需要配置appsettings
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});
```

### 连接字符串

在SSMS中，连接窗口左上角可以选择浏览->本地,找到本地服务器,然后在窗口中间点击`Connection String`得到连接字符串.

### 种子
创建种子数据

```C#
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);
    modelBuilder.Entity<Country>().ToTable("Countries");
    modelBuilder.Entity<Person>().ToTable("Persons");
    
    //从这里开始
    //Seed
    //Country
    var countriesJson = System.IO.File.ReadAllText("Countries.json");
    var countries = System.Text.Json.JsonSerializer.Deserialize<List<Country>>(countriesJson);

    foreach (var country in countries)
    {
        modelBuilder.Entity<Country>().HasData(country);
    }
    
    //Person
    var PersonsJson = System.IO.File.ReadAllText("Persons.json");
    var Persons = System.Text.Json.JsonSerializer.Deserialize<List<Person>>(PersonsJson);

    foreach (var person in Persons)
    {
        modelBuilder.Entity<Person>().HasData(person);
    }
}
```

>[!WARNING]
>注意HasData这个方法,一旦改了主键名称那么他会认为是新数据,旧数据全部丢失

### 迁移

>[!WARNING]
>**永远不要手动修改过去的迁移文件**,哪怕全部回滚再迁移都不行.EFCore有内部跟踪,会报错.

以设计的数据库生成代码.

~~安装`Microsoft.EntityFrameworkCore.Tools`~~

Rider项目上点击EFCore->迁移，他会提示你安装dotnet-ef 全局工具

依赖注入需要提供有参构造器
```C#
//Program.cs
//添加依赖注入并且传入options,默认为Scope
builder.Services.AddDbContext<PersonsDbContext>(options =>
{
    //使用配置
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});
```

```C#
//PersonsDbContext.cs
public class PersonsDbContext : DbContext
{
    //需要一个有参构造函数接收options,并且将options传入父类调用
    public PersonsDbContext(DbContextOptions  options):base(options)
    {
        
    }

}

//如果是分层架构，在非主项目内使用迁移而且没有使用VS包管理器,那么可能得不到options.那么要写工厂类
public class PersonsDbContextFactory:IDesignTimeDbContextFactory<PersonsDbContext>
{
    public PersonsDbContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<PersonsDbContext>();
        optionsBuilder.UseSqlServer("YOUR-ConnectionsString");
        return new PersonsDbContext(optionsBuilder.Options);
    }
}
```

>[!WARNING]
>用VS的包管理命令来使用EFCore有天然的优势  
>1.首先你可能不需要写`IDesignTimeDbContextFactory`，因为EFCore工具他不能直接运行你的程序,所以当你的`DbContext`的`options`是在主项目传入的，而你在另一个项目迁移它就得不到，所以要写工厂类.  
>2.其次如果你的种子数据在主项目里面,在其他项目迁移它也得不到,你迁移也报错,你需要在终端中命令行加入设置并且迁移,它才知道   
`dotnet ef --project Entities --startup-project CRUDExample migrations add Init`  
>如果你使用的是VS的包管理器可能不会遇到那么多问题,它包装了命令行,在你添加迁移或者其他命令时候会检测，自动帮你加入设置

迁移成功后它会在项目根目录创建`Migrations`文件夹,里面有迁移文件和快照文件.

迁移文件,其实就是帮你创表的代码,UP为创建代码,Down为回滚方法

删除迁移 会删除上一个,不能指定删除哪个,因为它只能按照顺序删除

` dotnet ef --project Entities --startup-project CRUDExample migrations remove`

### 更新 

按顺序更新到最近一个  
`dotnet ef database update --project Entities --startup-project CRUDExample`

也可以用来回退,给定序号或者迁移文件名  
` dotnet ef database update 0 --project Entities --startup-project CRUDExample   `

### 数据操作

LINQ to Entities 对EFCore数据使用LINQ

>[!WARNING]
>LINQ to Entities是和普通LINQ不同的,它会将方法转化为SQL语句在数据库执行，所以你**不能在lambda表达式中使用自己的方法**,因为数据库中没有,所以你应该将它ToList(),变成内存里面的数据脱离数据库.  
>没有Tolist()的数据其实是`IQuearyable`,没有真正的执行,是准备送往数据库的查询数据.

Query

`_dbContext.DbSetName.Where()`

`_dbContext.DbSetName.OrderBy()`

`_dbContext.DbSetName.Select()`

Update

`_dbContext.DbSetName.Add()`

`_dbContext.DbSetName.Remove()`

`_dbContext.SaveChanges()`

`entityObject.Property=value` 直接修改对象属性,EFCore会跟踪对象,内部有个EntityState的值.

`_dbContext.SaveChanges()`

### 存储过程

可以执行SQL语句,更加自由,但还是**推荐使用EFCore**.

-------

创建一个迁移过程,在UP和DOWN写上创建存储过程的SQL语句

```C#
public partial class GetPersons_StoredProcedure : Migration
{
    /// <inheritdoc />
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        //创建了存储过程
        string sp_GetAllPersons = @"
        CREATE PROCEDURE [dbo].[GetAllPersons]
        AS BEGIN
            SELECT * FROM [dbo].[Persons]
        END
        ";
        
        migrationBuilder.Sql(sp_GetAllPersons);
    }

    /// <inheritdoc />
    protected override void Down(MigrationBuilder migrationBuilder)
    {
        //卸载存储过程
        string sp_GetAllPersons = @"
        DROP PROCEDURE [dbo].[GetAllPersons]
        ";
        //执行sql
        migrationBuilder.Sql(sp_GetAllPersons);
    }
}
```
update迁移后,可以在数据库中看见`[dbo].[GetAllPersons]`这个存储过程

------

在DBContext中创建一个方法,来调用存储过程
```C#
public List<Person> sp_GetAllPersons()
{
    //Dbset<Persons> 会执行这个sql
    return Persons.FromSqlRaw("EXECUTE [dbo].[GetAllPersons]").ToList();
}
```

可以把LINQ换成存储过程试试,结果是一样的
```C#
public List<PersonResponse> GetAllPersons()
{
    
    //return _personsDbContext.Persons.ToList().Select(p => ConvertPersonToPersonResponse(p)).ToList();
    return _personsDbContext.sp_GetAllPersons().Select(p => ConvertPersonToPersonResponse(p)).ToList();
}
```
#### 带参数版本


创建一个迁移过程,在UP和DOWN写上创建存储过程的SQL语句

```C#
public partial class InsertPerson_StoredProcedure : Migration
{
    /// <inheritdoc />
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        string sp_InsertPerson = @"
        CREATE PROCEDURE [dbo].[InsertPerson](@PersonId uniqueidentifier,@PersonName nvarchar(40),@Email nvarchar(50),
            @DateOfBirth datetime2(7),@Gender varchar(10),@CountryID uniqueidentifier,@Address nvarchar(100),@ReceiveNewsLetters bit)
        AS BEGIN
            INSERT INTO [dbo].[Persons](PersonId ,PersonName ,Email,
            DateOfBirth ,Gender ,CountryID ,Address ,ReceiveNewsLetters ) 
            VALUES(@PersonId ,@PersonName ,@Email,
            @DateOfBirth,@Gender ,@CountryID ,@Address ,@ReceiveNewsLetters)
        END
        ";
        migrationBuilder.Sql(sp_InsertPerson);
    }

    /// <inheritdoc />
    protected override void Down(MigrationBuilder migrationBuilder)
    {
        string sp_InsertPerson = @"
        DROP PROCEDURE [dbo].[InsertPerson]
        ";
        migrationBuilder.Sql(sp_InsertPerson);
    }
}
```

在Dbcontext中创建方法
```C#
public int sp_InsertPerson(Person person)
{
    SqlParameter[] parameters = new SqlParameter[]
    {
        new SqlParameter("@PersonId", person.PersonId),
        new SqlParameter("@PersonName", person.PersonName),
        new SqlParameter("@Email", person.Email),
        new SqlParameter("@DateOfBirth", person.DateOfBirth),
        new SqlParameter("@Gender", person.Gender),
        new SqlParameter("@CountryID", person.CountryID),
        new SqlParameter("@Address", person.Address),
        new SqlParameter("@ReceiveNewsLetters", person.ReceiveNewsLetters),
    };
    return Database.ExecuteSqlRaw("EXECUTE [dbo].[InsertPerson] @PersonId ,@PersonName ,@Email, @DateOfBirth,@Gender ,@CountryID ,@Address ,@ReceiveNewsLetters", parameters);
}
```
调用,把LINQ换成存储过程
```C#
//_personsDbContext.Persons.Add(person);
//_personsDbContext.SaveChanges();

_personsDbContext.sp_InsertPerson(person);
```

#### 总结  
就是在迁移中使用SQL创建了存储过程到数据库,然后用执行sql的方法执行那个存储过程.

## 表关系

导航属性,默认为null,除非明确Include查询



```C#
public class Person
{
    //可以提及外键,非必须
    [ForeignKey("CountryId")]

    //仅仅创建一个Country类就得到了导航属性
    //是因为在Dbset中也注册了这个类,于是EFCore知道它来自于另一个表
    public Country? Country { get; set; }
}
```

```C#
public class Country
{
    public virtual ICollection<Person> Persons { get; set; }
}
```
调用
```C#
//"Country"是导航属性名不是类名.
var persons = _personsDbContext.Persons.Include("Country").ToList();

//用这种更好
var persons = _personsDbContext.Persons.Include(p=>p.Country).ToList();

```

>[!TIP]
>如果给导航属性添加`Virtual`有利于EFCore重写属性使用懒加载,但是懒加载有可能导致性能问题,所以还是推荐使用Include明确加载

也可以使用FluentAPI来配置



# 老版

## 安装

`Microsoft.EntityFrameworkCore.Core` 核心包 用来创建DBcontext 和DBset

`Microsoft.EntityFrameworkCore.SqlServer` 用来连SqlServer 可以替换

### 获取工具

`Microsoft.EntityFrameworkCore.Tools`
项目工具，如果没有这个就不能使用迁移，只能自己写sql语句

`Microsoft.EntityFrameworkCore.Design` 没用过

## 使用

JetBrains Rider: 项目解决方案右键EntityFrameworkCore，可视化.

Visual Studio

> `Add-Migration` 迁移， `update-Database` 更新数据库
>
> 第二种
>
> 右键项目-\> 添加 -\> 连接的服务 -\>
> 服务依赖项的省略号-\>添加迁移(或者更新数据库)

代码

> dbcontext.database.migrate(); 应用迁移 **如果没有迁移文件就没表**
>
> dbcontext.database.ensurecreated();
> 不应用迁移创建,安装dbcontext创建.两个不能共用.

## EFCore 设计时候

如果是WPF和Avalonia暂时还没解决

在avalonia中,rider 里面的 UI 无法使用，只能使用代码。

如果识别不到dbcontext,就要使用`IDesignTimeDbContextFactory`

## 项目文件

Data

Context 数据库上下文

Migration

迁移文件

UP 迁移方法

快照

## 语法

`OrderBy()` 排序 

`FirstAsync()` 第一个

`Include(p=>p.logs)` 链接集合并且返回数据,如果不链接(直接`People.logs`)，`logs`将为空，这是efcore的优化机制。

## 内存数据库

`Microsoft.EntityFrameworkCore.InMemory`
不推荐使用.仅用内存中的数据库，不需要依赖实际数据库.

建议使用sqlite提供的内存服务

`builder.Services.AddDbContext<TodoContext>(opt=>opt.UseInMemoryDatabase("TodoList"))`
数据库上下文

## 常见问题

在操作时要注意跟踪问题，由EFCore查询得到的实例可以直接操作，因为它已经跟踪知道是数据库的哪个，但是如果由参数传进来或改变了作用域，它有可能不认识，所以还是得写查询语句确定到具体哪个。

### WPF 问题

>[!CAUTION]
>
>迁移是设计时，不是运行时.
>
>如果使用依赖注入DBContext，在迁移的时候会报错。因为迁移有权限查找ASP中的Program.cs中的文件，但是WPF中没有
>所以它得不到容器中的对象也得不到AddDbContext中的参数
>
>要提供无参构造函数因为如果没有无参构造，又得不到依赖注入的参数就无法构建.并且要在DBcontext中的OnConfiguring
>()中设置配置.迁移会默认优先使用依赖注入，如果没有找到才会使用无参并且执行OnConfiguring.

### Avalonia

在linuxmint下 我的Rider 无法使用UI迁移，但是代码可以正常使用

### 映射

只有公共属性才会自动映射，字段需要自己配置

### 文件复制

需要将数据库文件的属性设置为始终复制

而且在运行的时候他修改的是bin里面的数据库,而不是项目源码里面的数据库