---
categories: ASP.net
---

# Entity Framework Core

内部使用的`ADO`,方便编写,性能相比略差。

默认使用依赖注入.

属性注释 [Key]为ID唯一值

## 使用

```C#
//DbContext对应的数据库
public class PersonsDbContext : DbContext
{
    //DbSet对应的是一张表,泛型,名称使用复数.
    public DbSet<Country> Countries { get; set; }
    public DbSet<Person> Persons { get; set; }

    //配置表
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.Entity<Country>().ToTable("Countries");
        modelBuilder.Entity<Person>().ToTable("Persons");
    }
}
```

```C#
//Program.cs
//依赖注入
builder.Services.AddDbContext<PersonsDbContext>(options =>
{
    //需要配置appsettings
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});
```

### 连接字符串

在SSMS中，连接窗口左上角可以选择浏览->本地,找到本地服务器,然后在窗口中间点击`Connection String`得到连接字符串.

### 种子
创建种子数据

```C#
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);
    modelBuilder.Entity<Country>().ToTable("Countries");
    modelBuilder.Entity<Person>().ToTable("Persons");
    
    //从这里开始
    //Seed
    //Country
    var countriesJson = System.IO.File.ReadAllText("Countries.json");
    var countries = System.Text.Json.JsonSerializer.Deserialize<List<Country>>(countriesJson);

    foreach (var country in countries)
    {
        modelBuilder.Entity<Country>().HasData(country);
    }
    
    //Person
    var PersonsJson = System.IO.File.ReadAllText("Persons.json");
    var Persons = System.Text.Json.JsonSerializer.Deserialize<List<Person>>(PersonsJson);

    foreach (var person in Persons)
    {
        modelBuilder.Entity<Person>().HasData(person);
    }
}
```

### 迁移

以设计的数据库生成代码.

~~安装`Microsoft.EntityFrameworkCore.Tools`~~

Rider项目上点击EFCore->迁移，他会提示你安装dotnet-ef 全局工具

依赖注入需要提供有参构造器
```C#
//Program.cs
//添加依赖注入并且传入options,默认为Scope
builder.Services.AddDbContext<PersonsDbContext>(options =>
{
    //使用配置
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});
```

```C#
//PersonsDbContext.cs
public class PersonsDbContext : DbContext
{
    //需要一个有参构造函数接收options,并且将options传入父类调用
    public PersonsDbContext(DbContextOptions  options):base(options)
    {
        
    }

}

//如果是分层架构，在非主项目内使用迁移而且没有使用VS包管理器,那么可能得不到options.那么要写工厂类
public class PersonsDbContextFactory:IDesignTimeDbContextFactory<PersonsDbContext>
{
    public PersonsDbContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<PersonsDbContext>();
        optionsBuilder.UseSqlServer("YOUR-ConnectionsString");
        return new PersonsDbContext(optionsBuilder.Options);
    }
}
```

>[!WARNING]
>用VS的包管理命令来使用EFCore有天然的优势  
>1.首先你可能不需要写`IDesignTimeDbContextFactory`，因为EFCore工具他不能直接运行你的程序,所以当你的`DbContext`的`options`是在主项目传入的，而你在另一个项目迁移它就得不到，所以要写工厂类.  
>2.其次如果你的种子数据在主项目里面,在其他项目迁移它也得不到,你迁移也报错,你需要在终端中命令行加入设置并且迁移,它才知道   
`dotnet ef --project Entities --startup-project CRUDExample migrations add Init`  
>如果你使用的是VS的包管理器可能不会遇到那么多问题,它包装了命令行,在你添加迁移或者其他命令时候会检测，自动帮你加入设置

迁移成功后它会在项目根目录创建`Migrations`文件夹,里面有迁移文件和快照文件.

迁移文件,其实就是帮你创表的代码,UP为创建代码,Down为回滚方法

删除迁移 会删除上一个

` dotnet ef --project Entities --startup-project CRUDExample migrations remove`

### 更新 

按顺序更新到最近一个  
`dotnet ef database update --project Entities --startup-project CRUDExample`

也可以用来回退,给定序号或者迁移文件名  
` dotnet ef database update 0 --project Entities --startup-project CRUDExample   `

### 数据操作

LINQ to Entities 对EFCore数据使用LINQ

>[!WARNING]
>LINQ to Entities是和普通LINQ不同的,它会将方法转化为SQL语句在数据库执行，所以你**不能在lambda表达式中使用自己的方法**,因为数据库中没有,所以你应该将它ToList(),变成内存里面的数据脱离数据库.  
>没有Tolist()的数据其实是`IQuearyable`,没有真正的执行,是准备送往数据库的查询数据.

Query

`_dbContext.DbSetName.Where()`

`_dbContext.DbSetName.OrderBy()`

`_dbContext.DbSetName.Select()`

Update

`_dbContext.DbSetName.Add()`

`_dbContext.DbSetName.Remove()`

`_dbContext.SaveChanges()`

`entityObject.Property=value` 直接修改对象属性,EFCore会跟踪对象,内部有个EntityState的值.

`_dbContext.SaveChanges()`

# 老版

## 安装

`Microsoft.EntityFrameworkCore.Core` 核心包 用来创建DBcontext 和DBset

`Microsoft.EntityFrameworkCore.SqlServer` 用来连SqlServer 可以替换

### 获取工具

`Microsoft.EntityFrameworkCore.Tools`
项目工具，如果没有这个就不能使用迁移，只能自己写sql语句

`Microsoft.EntityFrameworkCore.Design` 没用过

## 使用

JetBrains Rider: 项目解决方案右键EntityFrameworkCore，可视化.

Visual Studio

> `Add-Migration` 迁移， `update-Database` 更新数据库
>
> 第二种
>
> 右键项目-\> 添加 -\> 连接的服务 -\>
> 服务依赖项的省略号-\>添加迁移(或者更新数据库)

代码

> dbcontext.database.migrate(); 应用迁移 **如果没有迁移文件就没表**
>
> dbcontext.database.ensurecreated();
> 不应用迁移创建,安装dbcontext创建.两个不能共用.

## EFCore 设计时候

如果是WPF和Avalonia暂时还没解决

在avalonia中,rider 里面的 UI 无法使用，只能使用代码。

如果识别不到dbcontext,就要使用`IDesignTimeDbContextFactory`

## 项目文件

Data

Context 数据库上下文

Migration

迁移文件

UP 迁移方法

快照

## 语法

`OrderBy()` 排序 

`FirstAsync()` 第一个

`Include(p=>p.logs)` 链接集合并且返回数据,如果不链接(直接`People.logs`)，`logs`将为空，这是efcore的优化机制。

## 内存数据库

`Microsoft.EntityFrameworkCore.InMemory`
不推荐使用.仅用内存中的数据库，不需要依赖实际数据库.

建议使用sqlite提供的内存服务

`builder.Services.AddDbContext<TodoContext>(opt=>opt.UseInMemoryDatabase("TodoList"))`
数据库上下文

## 常见问题

在操作时要注意跟踪问题，由EFCore查询得到的实例可以直接操作，因为它已经跟踪知道是数据库的哪个，但是如果由参数传进来或改变了作用域，它有可能不认识，所以还是得写查询语句确定到具体哪个。

### WPF 问题

>[!CAUTION]
>
>迁移是设计时，不是运行时.
>
>如果使用依赖注入DBContext，在迁移的时候会报错。因为迁移有权限查找ASP中的Program.cs中的文件，但是WPF中没有
>所以它得不到容器中的对象也得不到AddDbContext中的参数
>
>要提供无参构造函数因为如果没有无参构造，又得不到依赖注入的参数就无法构建.并且要在DBcontext中的OnConfiguring
>()中设置配置.迁移会默认优先使用依赖注入，如果没有找到才会使用无参并且执行OnConfiguring.

### Avalonia

在linuxmint下 我的Rider 无法使用UI迁移，但是代码可以正常使用

### 映射

只有公共属性才会自动映射，字段需要自己配置

### 文件复制

需要将数据库文件的属性设置为始终复制

而且在运行的时候他修改的是bin里面的数据库,而不是项目源码里面的数据库