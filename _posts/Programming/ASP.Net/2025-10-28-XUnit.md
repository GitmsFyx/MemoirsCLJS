---
categories: ASP.net
---
# XUnit
在解决方案创建新项目选择`XUnit`

>[!IMPORTANT]
>每个测试用例默认独立执行,不会互相影响

创建一个方法
```C#
class MyMath
{
    public int Add(int a, int b)
    {
        return a + b;
    }
}
```
测试类  
将实际输出和期望输出对比.查看方法是否正确.
```C#
public class UnitTest1
{
    //由Fact修饰,说明它是一个测试方法
    [Fact]
    public void Test1()
    {
        //Arrange 准备
        MyMath mm = new MyMath();
        int input1 = 10, input2 = 5;
        int expected = 15;
        
        //Act 执行
        int actual=mm.Add(input1, input2);
        
        //Assert 断言
        Assert.Equal(expected, actual);
    }
}
```

将鼠标放在`Test1()`上右键运行单元测试.自动跳出测试窗口.

可以用`#region`划分区域

## 断言方法
```C#
#Assert

//断言抛出异常,ArgumentException参数错误
Assert.Throws<ArgumentException>(() =>{method()});

//断言为空
Assert.Empty(args);

//args1是否包含在args2中
//Warning:这里用的是Equals()方法,引用类型比较的是地址
Assert.Contains(args1,args2);

//断言为null
Assert.Null();
```

## 打印

```C#
private readonly ITestOutputHelper _testOutputHelper;

//内置
public PersonsesServiceTest(ITestOutputHelper testOutputHelper)
{
    _testOutputHelper = testOutputHelper;
}

//打印
_testOutputHelper.WriteLine("Expected:");
_testOutputHelper.WriteLine(personResponse1.ToString());
_testOutputHelper.WriteLine(personResponse2.ToString());
```

其实就是和`cw`差不多,只不过是打印到单元测试那里。

## 异步

//断言抛出异常,ArgumentException参数错误  
`Assert.ThrowsAsync<ArgumentException>(async () => await _countriesService.AddCountry(request))`

## 工具

* Rider -> 工具 -> 生成GUID
* Mockaroo网站

## 最佳实践

*   **独立** (与其他类和文件系统,数据库隔离)
*   **一次测试一个方法** (方法测试不应该调用其他方法,因为调用也是测试)
*   无序测试

---

*   快,毫秒级别 (如果不是那么很有可能依赖了数据库或者其他系统)
*   可重复的
*   Timely (编写测试方法的时间不应超过编写方法的时间)

>[!IMPORTANT]
>有时候模拟方法的时候，传入同一个自动生成的数据,不是因为它们是同一个数据,而是因为这两个数据都不重要，特别是来自于数据库的，如果两个得到的数据都不重要那么,只传入一个还方便一点。

### 模拟DBContext

`Moq` 安装NuGet包

`EntityFrameworkCoreMock.Moq` 自己Mock数据库有点复杂,可以用这个包

演示
```C#
//ICountriesService 需要数据库
private readonly ICountriesService _countriesService;

public CountriesServiceTest()
{
    //创建一个空列表
    var countriesInitialData = new List<Country>() { };
    
    //Mcok数据库,new DbContextOptionsBuilder<ApplicationDbContext>().Options可以创建数据库所需的默认options.
    var dbContextMock = new DbContextMock<ApplicationDbContext>(new DbContextOptionsBuilder<ApplicationDbContext>().Options);

    //原来的方法,依赖了实际的数据库
    //var dbContext = new ApplicationDbContext(new DbContextOptionsBuilder<ApplicationDbContext>().Options);
    
    //为Mock的数据库创建MockDbSet,这里要将Dbset改为Virtual,方便Mock重写.
    dbContextMock.CreateDbSetMock(db => db.Countries, countriesInitialData);
    
    //模拟的数据库在Mock的object里面
    var dbContext = dbContextMock.Object;

    _countriesService = new CountriesService(dbContext);
}
```

### 模拟仓储

```C#
_personsRepositoryMock = new Mock<IPersonsRepository>();
_personsRepository = _personsRepositoryMock.Object;

//Mock方法，无论传入什么Person，都返回已经提供的固定的person
_personsRepositoryMock.Setup(temp => temp.AddPerson(It.IsAny<Person>())).ReturnsAsync(person);

//这里_personsService.AddPerson其实调用了_personsRepository.AddPerson
var personResponse =await _personsService.AddPerson(personAddRequest);

```
### 模拟控制器



### AutoFixture

自动创建示例并且填充测试数据.

先在构造器函数里new一个
```C#
private readonly IFixture _fixture;

public PersonsesServiceTest(ITestOutputHelper testOutputHelper)
{
    _fixture = new Fixture();
}
```
使用
```C#
//原本的方法
/*var personAddRequest = new PersonAddRequest()
{
    PersonName = "John Doe",
    Email = "person@example.com",
    Address = "sample address",
    CountryID = Guid.NewGuid(),
    Gender = GenderOptions.Male,
    DateOfBirth = DateTime.Parse("1990-01-01"),
    ReceiveNewsLetters = true,
};*/

//这里自动创建的Email过不了验证,因为它默认使用简单的GUID创建
//var personAddRequest = _fixture.Create<PersonAddRequest>();

//先Build,再在With里设置Emial为固定值,在创建
var personAddRequest = _fixture.Build<PersonAddRequest>()
    .With(p=>p.Email,"someone@example.com")
    .Create();
```

