---
categories: Unity
---

# 开始

*   VS 现在实现方法自动`throw`,有可能在unity中不习惯.  
可以在工具->文本编辑器->C#->高级  
底部生成属性时首选引发属性->首选自动属性

*   设置锚点的时候按`Alt`键可以同时设置位置

*   UI设置了世界空间要加入事件摄像机,要不然点击不了

*   VS 编辑器 如果没有解决方案直接重新载入就可以

*   [SerializeField] 预制体只能拖预制体 ,示例的都可以拖
*   `Instantiate` 接受的用的是世界坐标
*   建议都以世界坐标为标准，因为世界坐标只有一个，相对坐标可以改变.


## 重要 

问题:当一个gameobject被销毁了(`Destroy()`),它被接口所引用判断`null`仍然为`false`  

    因为Destroy()是Unity的方法,底层用的是C++，而接口是C#原生的，它必须依靠GC回收器回收为null,那么Unity无法直接更改接口为null,导致不同.

    解决方法:不要直接判断原生接口(强转也没有用),判断unity提供的API,object或者其他,它们能收到更改.

    总结:两个内存回收的方式不同,既然是unity回收的就得用unity提供的API.

过于追求组合大于继承会徒增麻烦。  
组合应该用于通用功能，而且不应对原本功能有干涩和冲突。  
如果只使用接口组合，那么每次都要重新编写初始值和属性的一些逻辑代码。
该用抽象类继承的时候就用好了。


    unity的检查器中,只能拖入`MonoBehaviour`,不能直接拖入`script`.哪怕是声明了匹配的接口类型也拖不进去. 

    是因为它需要和unity引擎绑定,要在外面套一层空对象,管理生命周期,哪怕是用代码直接new也加不进去

根对象不要缩放，因为在添加子类的时候,子类会变形.

## 坑

Unity的UI,`layout`有点垃圾,一旦嵌套乱很乱,  
用了布局子类一定要添加`layout Element`.